<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OMNISCIENCE X</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#030406;--panel:#070910;--border:rgba(255,255,255,0.025);--dim:rgba(160,175,200,0.25);--text:rgba(160,175,200,0.55);--bright:rgba(200,215,240,0.8);--blue:rgba(107,150,255,0.6);--gold:rgba(255,200,80,0.6);--green:rgba(100,220,150,0.5);--red:rgba(255,100,100,0.5);--purple:rgba(167,139,250,0.5)}
body{background:var(--bg);color:var(--text);font-family:system-ui,sans-serif;height:100vh;overflow:hidden;font-weight:300}
.layout{display:grid;grid-template-columns:1fr 280px;grid-template-rows:auto 1fr auto;height:100vh}
@media(max-width:800px){.layout{grid-template-columns:1fr;grid-template-rows:auto 1fr auto}.right{display:none}}
.topbar{grid-column:1/-1;padding:6px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:6px}
.topbar h1{font-size:9px;letter-spacing:7px;text-transform:uppercase;opacity:0.08;font-weight:200}
.topbar .metrics{display:flex;gap:10px;font:8px/1 monospace;color:var(--dim);flex-wrap:wrap}
.topbar .metrics b{font-weight:400}
.topbar .metrics b.blue{color:var(--blue)}
.topbar .metrics b.green{color:var(--green)}
.topbar .metrics b.purple{color:var(--purple)}
.center{grid-column:1;grid-row:2;display:flex;flex-direction:column;min-width:0;min-height:0;overflow:hidden}
.tabs{display:flex;border-bottom:1px solid var(--border);flex-shrink:0}
.tab{padding:6px 14px;font-size:8px;letter-spacing:2px;text-transform:uppercase;opacity:0.15;cursor:pointer;border-bottom:2px solid transparent}
.tab.active{opacity:0.4;border-bottom-color:rgba(107,150,255,0.2)}
.view{flex:1;overflow:hidden;display:none;flex-direction:column}
.view.active{display:flex}
canvas#graphCanvas{flex:1;cursor:grab}
.chat{flex:1;overflow-y:auto;padding:10px 14px;display:flex;flex-direction:column;gap:6px}
.msg{max-width:88%;padding:9px 13px;border-radius:7px;line-height:1.65;font-size:12px;animation:fi .3s}
.msg.u{align-self:flex-end;background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.04);color:rgba(255,255,255,0.45)}
.msg.ai{align-self:flex-start;background:rgba(107,140,255,0.025);border:1px solid rgba(107,140,255,0.05);color:rgba(140,170,255,0.6)}
.msg .chain{font:8px/1.4 monospace;opacity:0.35;margin-bottom:5px;border-left:2px solid rgba(107,150,255,0.08);padding-left:7px;max-height:60px;overflow-y:auto;word-break:break-word}
.msg .conf{display:inline-block;font:7.5px monospace;padding:1px 4px;border-radius:2px;margin:0 1px}
.msg .conf.high{background:rgba(100,220,150,0.08);color:var(--green)}
.msg .conf.med{background:rgba(255,200,80,0.08);color:var(--gold)}
.msg .conf.low{background:rgba(255,100,100,0.08);color:var(--red)}
.msg .web{background:rgba(167,139,250,0.04);border:1px solid rgba(167,139,250,0.07);border-radius:4px;padding:4px 8px;margin:4px 0;font-size:10px;color:var(--purple)}
.msg.sys{align-self:center;font:8.5px monospace;opacity:0.1;background:none;border:none}
.msg .fetching{color:var(--purple);font-size:10px;opacity:0.4;font-style:italic}
.reasoning-view{flex:1;overflow-y:auto;padding:10px;font:9.5px/1.5 monospace;color:var(--dim)}
.r-step{padding:5px 7px;border-left:2px solid rgba(107,150,255,0.06);margin:3px 0;background:rgba(107,150,255,0.01)}
.r-step.web{border-left-color:rgba(167,139,250,0.2);background:rgba(167,139,250,0.02)}
.r-step .label{font-size:7px;letter-spacing:2px;text-transform:uppercase;opacity:0.3;margin-bottom:1px}
.r-step .content{opacity:0.35}
.right{grid-column:2;grid-row:2/4;background:var(--panel);border-left:1px solid var(--border);overflow-y:auto;padding:8px;font:8.5px/1.5 monospace}
.right h4{font-size:6.5px;letter-spacing:3px;text-transform:uppercase;opacity:0.12;margin:8px 0 3px}
.right .row{display:flex;justify-content:space-between;padding:1px 0;opacity:0.2}
.right .row b{font-weight:400;opacity:1}
.right .edge-item{font-size:7.5px;opacity:0.18;padding:2px 0;border-bottom:1px solid rgba(255,255,255,0.01);line-height:1.4}
.right .tag{display:inline-block;font-size:7px;padding:1px 4px;border-radius:2px;margin:1px}
.right .tag.web{background:rgba(167,139,250,0.08);color:var(--purple)}
.right .tag.user{background:rgba(107,150,255,0.06);color:var(--blue)}
.right .tag.inferred{background:rgba(100,220,150,0.06);color:var(--green)}
.input-bar{grid-column:1;grid-row:3;padding:6px 14px;border-top:1px solid var(--border);display:flex;gap:5px}
.input-bar input{flex:1;background:rgba(255,255,255,0.015);border:1px solid var(--border);border-radius:5px;padding:9px 12px;color:var(--bright);font:12px system-ui;font-weight:300;outline:none}
.input-bar input:focus{border-color:rgba(107,150,255,0.1)}
.input-bar input::placeholder{color:rgba(255,255,255,0.05)}
.input-bar button{background:rgba(107,150,255,0.04);border:1px solid rgba(107,150,255,0.07);border-radius:5px;padding:9px 12px;color:rgba(107,150,255,0.35);cursor:pointer;font:10px system-ui;white-space:nowrap}
@keyframes fi{from{opacity:0;transform:translateY(3px)}to{opacity:1;transform:translateY(0)}}
.loading{display:inline-block;width:12px;height:12px;border:1.5px solid rgba(167,139,250,0.15);border-top-color:var(--purple);border-radius:50%;animation:spin .8s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<div class="layout">
<div class="topbar">
<h1>omniscience x</h1>
<div class="metrics">
concepts <b class="blue" id="mC">0</b>
edges <b class="blue" id="mE">0</b>
web-learned <b class="purple" id="mW">0</b>
inferred <b class="green" id="mI">0</b>
confidence <b class="blue" id="mConf">â€”</b>
</div>
</div>
<div class="center">
<div class="tabs">
<div class="tab active" onclick="switchView('chat')">dialogue</div>
<div class="tab" onclick="switchView('graph')">knowledge graph</div>
<div class="tab" onclick="switchView('reasoning')">reasoning trace</div>
</div>
<div class="view active" id="v-chat"><div class="chat" id="chat"></div></div>
<div class="view" id="v-graph"><canvas id="graphCanvas"></canvas></div>
<div class="view" id="v-reasoning"><div class="reasoning-view" id="reasoningView"></div></div>
</div>
<div class="right" id="rightPanel"></div>
<div class="input-bar">
<input id="in" placeholder="ask anything â€” i'll search the web to learn..." onkeydown="event.key==='Enter'&&go()">
<button onclick="go()">think â†’</button>
</div>
</div>

<script>
/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  O M N I S C I E N C E   X                                             â•‘
â•‘                                                                          â•‘
â•‘  Everything from Omniscience PLUS:                                       â•‘
â•‘  â€¢ ConceptNet API â€” 34 million common-sense facts, live                  â•‘
â•‘  â€¢ Wikipedia API â€” summaries of everything, live                         â•‘
â•‘  â€¢ Auto-learning: asks about unknown concept â†’ fetches from web          â•‘
â•‘  â€¢ Web knowledge tagged and tracked separately from user knowledge       â•‘
â•‘  â€¢ Blends human-taught + web-learned + inferred knowledge                â•‘
â•‘  â€¢ All transparent. All traceable. All free.                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
*/

// â•â•â•â•â•â•â•â• KNOWLEDGE GRAPH â•â•â•â•â•â•â•â•
const D=32;let nid=0,webLearnedCount=0,inferenceCount=0

class Node{
 constructor(n,type='entity'){
  this.id=nid++;this.name=n;this.type=type;this.embedding=new Float32Array(D)
  this.sources=1;this.activation=0;this.accessCount=0;this.contested=false
  this.webEnriched=false;this.lastAccess=Date.now()
  for(let i=0;i<D;i++){let h=0;for(let j=0;j<n.length;j++)h=((h<<5)-h+n.charCodeAt(j)+i*7)|0;this.embedding[i]=((h%1000)/500-1)*0.4}
 }
}

class Edge{
 constructor(f,t,r,c=0.8){
  this.from=f;this.to=t;this.rel=r;this.confidence=c;this.sources=1;this.strength=1
  this.contested=false;this.source='user';this.contradictions=[]
 }
 reinforce(src){this.sources++;this.strength=Math.min(3,this.strength+0.2);this.confidence=Math.min(0.99,this.confidence+0.02)}
}

class KG{
 constructor(){this.nodes=new Map();this.edges=[];this.edgeIdx=new Map();this.contradictions=[]}

 add(name,type='entity'){
  name=name.toLowerCase().trim().replace(/[^a-z0-9\s\-']/g,'')
  if(!name||name.length<2)return null
  for(let[_,n]of this.nodes)if(n.name===name){n.sources++;return n}
  let n=new Node(name,type);this.nodes.set(n.id,n);this.edgeIdx.set(n.id,[]);return n
 }

 find(name){
  name=name.toLowerCase().trim()
  for(let[_,n]of this.nodes)if(n.name===name)return n
  return null
 }

 link(fn,tn,rel,conf=0.8,source='user'){
  let a=this.add(fn),b=this.add(tn)
  if(!a||!b||a.id===b.id)return null
  let existing=this.edges.find(e=>e.from===a.id&&e.to===b.id&&e.rel===rel)
  if(existing){existing.reinforce(source);return existing}
  // Contradiction check
  let dominated=this.checkContradiction(a,b,rel)
  let e=new Edge(a.id,b.id,rel,conf);e.source=source
  if(dominated)e.contested=true
  this.edges.push(e);this.edgeIdx.get(a.id).push({edge:e,dir:'out'});this.edgeIdx.get(b.id).push({edge:e,dir:'in'})
  for(let i=0;i<D;i++){let d=(b.embedding[i]-a.embedding[i])*0.04;a.embedding[i]+=d;b.embedding[i]-=d*0.2}
  if(source==='web')webLearnedCount++
  if(source==='inferred')inferenceCount++
  return e
 }

 checkContradiction(a,b,rel){
  const opp={is:'is_not',is_not:'is',causes:'prevents',prevents:'causes',increases:'decreases',decreases:'increases'}
  let o=opp[rel];if(!o)return false
  let ex=this.edges.find(e=>e.from===a.id&&e.to===b.id&&e.rel===o)
  if(ex){ex.contested=true;this.contradictions.push({a:a.name,b:b.name,rel1:o,rel2:rel});return true}
  return false
 }

 edgesOf(id){
  return(this.edgeIdx.get(id)||[]).map(({edge:e,dir})=>({
   rel:e.rel,node:this.nodes.get(dir==='out'?e.to:e.from),
   strength:e.strength,confidence:e.confidence,sources:e.sources,
   dir,edge:e,contested:e.contested,source:e.source
  }))
 }

 similarity(a,b){
  if(!a||!b)return 0;let d=0,ma=0,mb=0
  for(let i=0;i<D;i++){d+=a.embedding[i]*b.embedding[i];ma+=a.embedding[i]**2;mb+=b.embedding[i]**2}
  return d/(Math.sqrt(ma)*Math.sqrt(mb)+1e-8)
 }

 findSimilar(id,n=5){
  let t=this.nodes.get(id);if(!t)return[]
  let r=[];for(let[i,node]of this.nodes){if(i===id)continue;r.push({node,sim:this.similarity(t,node)})}
  return r.sort((a,b)=>b.sim-a.sim).slice(0,n)
 }

 multiHop(startId,goalId=null,maxH=6){
  let paths=[],queue=[{id:startId,path:[],conf:1,visited:new Set([startId])}]
  while(queue.length>0&&paths.length<5){
   let{id,path,conf,visited}=queue.shift()
   if(path.length>=maxH)continue
   if(goalId&&id===goalId&&path.length>0){paths.push({path,confidence:conf});continue}
   let edges=this.edgesOf(id).filter(e=>e.node&&!visited.has(e.node.id)).sort((a,b)=>(b.confidence*b.strength)-(a.confidence*a.strength))
   for(let e of edges.slice(0,6)){
    let nc=conf*e.confidence*(e.contested?0.5:1);if(nc<0.03)continue
    let nv=new Set(visited);nv.add(e.node.id)
    let step={from:this.nodes.get(id),rel:e.rel,to:e.node,confidence:e.confidence,sources:e.sources,contested:e.contested,source:e.source}
    let np=[...path,step]
    if(!goalId&&np.length>=2)paths.push({path:np,confidence:nc})
    queue.push({id:e.node.id,path:np,conf:nc,visited:nv})
   }
  }
  return paths.sort((a,b)=>b.confidence-a.confidence)
 }

 spread(startId,steps=3,decay=0.5){
  let activated=new Map(),queue=[{id:startId,s:1}]
  for(let step=0;step<steps;step++){
   let next=[]
   for(let{id,s}of queue){
    if(activated.has(id)&&activated.get(id)>=s)continue
    activated.set(id,s);let n=this.nodes.get(id);if(n)n.activation=Math.max(n.activation,s)
    for(let e of this.edgesOf(id)){if(e.node)next.push({id:e.node.id,s:s*decay*e.strength})}
   }
   queue=next
  }
  return[...activated.entries()].sort((a,b)=>b[1]-a[1]).map(([id,s])=>({node:this.nodes.get(id),s}))
 }

 counterfactual(nodeId){
  let node=this.nodes.get(nodeId);if(!node)return[]
  let effects=[]
  let causal=this.edgesOf(nodeId).filter(e=>['causes','leads_to','increases','decreases','enables'].includes(e.rel))
  for(let e of causal){
   let inv={causes:'would not happen',increases:'would decrease',decreases:'would increase',enables:'would be disabled',leads_to:'would not follow'}
   effects.push({effect:`${e.node?.name} ${inv[e.rel]||'affected'}`,confidence:e.confidence*0.7,source:e.source})
   if(e.node){
    let downstream=this.edgesOf(e.node.id).filter(ee=>['causes','increases','decreases'].includes(ee.rel))
    for(let d of downstream.slice(0,2)){
     effects.push({effect:`ripple: ${d.node?.name} also affected`,confidence:e.confidence*d.confidence*0.5,source:'chain'})
    }
   }
  }
  return effects
 }

 decay(){for(let[_,n]of this.nodes)n.activation*=0.9}
 get size(){return this.nodes.size}
 get edgeCount(){return this.edges.length}
}

// â•â•â•â•â•â•â•â• WEB KNOWLEDGE ACQUISITION â•â•â•â•â•â•â•â•
const webCache=new Map()

async function fetchConceptNet(concept){
 concept=concept.toLowerCase().trim().replace(/\s+/g,'_')
 let key='cn:'+concept
 if(webCache.has(key))return webCache.get(key)
 try{
  let resp=await fetch(`https://api.conceptnet.io/c/en/${concept}?limit=40&offset=0`)
  if(!resp.ok)return null
  let data=await resp.json()
  let facts=[]
  for(let edge of(data.edges||[])){
   let start=edge.start?.label?.toLowerCase()
   let end=edge.end?.label?.toLowerCase()
   let rel=edge.rel?.label?.toLowerCase()
   let weight=edge.weight||1
   if(!start||!end||!rel)continue
   if(edge.start?.language&&edge.start.language!=='en')continue
   if(edge.end?.language&&edge.end.language!=='en')continue
   // Map ConceptNet relations to our relations
   let mapped=mapConceptNetRel(rel)
   if(mapped)facts.push({from:start,to:end,rel:mapped,confidence:Math.min(0.95,weight/4),source:'conceptnet'})
  }
  webCache.set(key,facts)
  return facts
 }catch(e){return null}
}

function mapConceptNetRel(rel){
 const map={
  'is a':'is_a','is':'is','has a':'has','has':'has','part of':'part_of',
  'used for':'used_for','capable of':'can','causes':'causes',
  'motivated by goal':'motivated_by','desires':'desires',
  'created by':'created_by','synonym':'similar_to',
  'antonym':'opposite_of','similar to':'similar_to','related to':'related',
  'at location':'located_in','has context':'context','defined as':'is',
  'made of':'made_of','has property':'has_property',
  'receives action':'receives','has subevent':'contains_event',
  'has prerequisite':'requires','has first subevent':'starts_with',
  'has last subevent':'ends_with','symbol of':'symbolizes',
  'manner of':'manner_of','distinct from':'different_from',
  'etymologically related to':'related','derived from':'derived_from',
  'instance of':'is_a','not desires':'avoids','not capable of':'cannot',
  'external url':'skip','dbpedia':'skip'
 }
 return map[rel]||null
}

async function fetchWikipedia(concept){
 concept=concept.trim()
 let key='wp:'+concept
 if(webCache.has(key))return webCache.get(key)
 try{
  let resp=await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(concept)}`)
  if(!resp.ok)return null
  let data=await resp.json()
  // Skip disambiguation pages â€” they don't contain useful facts
  if(data.type==='disambiguation'||data.description?.includes('disambiguation'))return null
  let result={title:data.title||concept,summary:data.extract||'',description:data.description||''}
  webCache.set(key,result)
  return result
 }catch(e){return null}
}

function extractFactsFromSummary(concept,summary){
 let facts=[]
 let sentences=summary.split(/\.\s+/).slice(0,5)
 for(let s of sentences){
  s=s.toLowerCase().trim()
  let patterns=[
   [/^(.+?) is (?:a|an|the) (.+?)$/,'is_a'],
   [/^(.+?) (?:is|are|was|were) (.+?)$/,'is'],
   [/^(.+?) has (.+?)$/,'has'],
   [/^(.+?) (?:contains?|includes?) (.+?)$/,'contains'],
   [/^(.+?) (?:causes?|leads? to) (.+?)$/,'causes'],
  ]
  for(let[regex,rel]of patterns){
   let m=s.match(regex)
   if(m){
    let subj=m[1].trim().slice(0,50),obj=m[2].trim().slice(0,50)
    if(subj.length>2&&obj.length>2)facts.push({from:subj,to:obj,rel,confidence:0.7,source:'wikipedia'})
   }
  }
 }
 return facts
}

// â•â•â•â•â•â•â•â• AUTO-ENRICHMENT ENGINE â•â•â•â•â•â•â•â•
async function enrichConcept(concept,trace){
 let node=kg.find(concept)
 let existingEdges=node?kg.edgesOf(node.id).length:0

 // Only fetch if we don't have much knowledge
 if(existingEdges>5)return{fetched:0,facts:[]}

 trace.push({label:'web search',content:`fetching knowledge about "${concept}" from ConceptNet + Wikipedia...`,web:true})

 let allFacts=[]

 // ConceptNet
 let cnFacts=await fetchConceptNet(concept)
 if(cnFacts&&cnFacts.length>0){
  let added=0
  for(let f of cnFacts.slice(0,25)){
   if(f.rel==='skip')continue
   let edge=kg.link(f.from,f.to,f.rel,f.confidence,'web')
   if(edge)added++
  }
  allFacts.push(...cnFacts.slice(0,25))
  trace.push({label:'conceptnet',content:`${added} facts learned from ConceptNet`,web:true})

  // Mark node as web-enriched
  let n=kg.find(concept)
  if(n)n.webEnriched=true
 }

 // Wikipedia
 let wiki=await fetchWikipedia(concept)
 if(wiki&&wiki.summary){
  // Store summary in cache with concept key for later retrieval in responses
  webCache.set('wp:'+concept,wiki)
  let n=kg.find(concept)||kg.add(concept)
  if(n&&wiki.description&&!wiki.description.includes('disambiguation')){
   kg.link(concept,wiki.description,'described_as',0.85,'wikipedia')
  }
  let wpFacts=extractFactsFromSummary(concept,wiki.summary)
  for(let f of wpFacts.slice(0,10)){
   kg.link(f.from,f.to,f.rel,f.confidence,'web')
  }
  allFacts.push(...wpFacts)
  trace.push({label:'wikipedia',content:`"${wiki.summary.slice(0,120)}..."`,web:true})
 }

 return{fetched:allFacts.length,facts:allFacts}
}

// Enrich multiple concepts in parallel
async function enrichAll(concepts,trace){
 let total=0
 let promises=concepts.slice(0,5).map(c=>enrichConcept(c,trace))
 let results=await Promise.allSettled(promises)
 for(let r of results){if(r.status==='fulfilled')total+=r.value.fetched}
 return total
}

// â•â•â•â•â•â•â•â• LOGIC ENGINE â•â•â•â•â•â•â•â•
class Logic{
 constructor(kg){this.kg=kg;this.rules=[];this.inferences=[];this.hypotheses=[]}
 deduct(node){
  let results=[],edges=this.kg.edgesOf(node.id)
  let parents=edges.filter(e=>e.rel==='is_a'&&e.dir==='out')
  for(let p of parents){
   if(!p.node)continue
   for(let pe of this.kg.edgesOf(p.node.id)){
    if(pe.dir==='out'&&pe.rel!=='is_a'&&pe.node){
     let exists=edges.find(e=>e.rel===pe.rel&&e.node?.name===pe.node?.name)
     if(!exists){
      let conf=pe.confidence*p.confidence*0.8
      results.push({subject:node.name,rel:pe.rel,object:pe.node.name,from:p.node.name,confidence:conf})
      this.kg.link(node.name,pe.node.name,pe.rel,conf,'inferred')
     }
    }
   }
  }
  this.inferences.push(...results);return results
 }
 abduct(node){
  let results=[],edges=this.kg.edgesOf(node.id)
  for(let e of edges){
   if(!e.node||e.dir!=='out')continue
   let shared=this.kg.edgesOf(e.node.id).filter(ee=>ee.dir==='in'&&ee.rel===e.rel&&ee.node&&ee.node.id!==node.id)
   for(let s of shared.slice(0,3)){
    results.push({hypothesis:`${node.name} may be related to ${s.node.name}`,reason:`both ${e.rel} ${e.node.name}`,confidence:Math.min(e.confidence,s.confidence)*0.4})
   }
  }
  this.hypotheses.push(...results.slice(0,5))
  return results.sort((a,b)=>b.confidence-a.confidence).slice(0,5)
 }
}

// â•â•â•â•â•â•â•â• ANALOGY ENGINE â•â•â•â•â•â•â•â•
class Analogy{
 constructor(kg){this.kg=kg;this.found=[]}
 find(source){
  let sEdges=this.kg.edgesOf(source.id),sRels=sEdges.map(e=>e.rel)
  let best=null,bestScore=0
  for(let[id,c]of this.kg.nodes){
   if(id===source.id)continue
   let cRels=this.kg.edgesOf(id).map(e=>e.rel)
   let overlap=sRels.filter(r=>cRels.includes(r)).length
   let score=overlap/Math.max(sRels.length,cRels.length,1)
   let sim=this.kg.similarity(source,c)
   if(sim>0.7)score*=0.3;if(sim<0.2)score*=1.5
   if(score>bestScore&&score>0.2){bestScore=score;best={node:c,score}}
  }
  if(best){
   let r={source:source.name,target:best.node.name,score:bestScore}
   this.found.push(r);return r
  }
  return null
 }
}

// â•â•â•â•â•â•â•â• MEMORY â•â•â•â•â•â•â•â•
class Memory{
 constructor(){this.episodes=[];this.patterns=[]}
 store(i,r,c,ch,conf){
  this.episodes.push({input:i,response:r,concepts:c,chain:ch,confidence:conf,time:Date.now()})
  if(this.episodes.length>300)this.episodes=this.episodes.slice(-250)
  if(this.episodes.length%8===0)this.consolidate()
 }
 recall(concepts,n=3){
  return this.episodes.map(ep=>{
   let overlap=concepts.filter(c=>ep.concepts.includes(c)).length
   return{...ep,score:overlap*3+1/(1+(Date.now()-ep.time)/(1000*60*60))}
  }).sort((a,b)=>b.score-a.score).slice(0,n)
 }
 consolidate(){
  let freq={};this.episodes.slice(-15).forEach(e=>e.concepts.forEach(c=>freq[c]=(freq[c]||0)+1))
  let top=Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,5)
  if(top.length>0)this.patterns.push({concepts:top.map(([c])=>c),time:Date.now()})
  if(this.patterns.length>30)this.patterns=this.patterns.slice(-20)
 }
}

// â•â•â•â•â•â•â•â• NLU â•â•â•â•â•â•â•â•
const STOP=new Set('the a an is are was were be been being have has had do does did will would shall should may might can could and but or nor for yet so at by from in into of on to with as if then than that this these those it its he she they we you i me my our your his her their what which who whom when where why how all each every both few many much some any no not very also just only even still already about after could would'.split(' '))

function parse(text){
 let raw=text.trim(),lower=raw.toLowerCase()
 let concepts=lower.replace(/[^a-z\s'-]/g,'').split(/\s+/).filter(w=>!STOP.has(w)&&w.length>2)
 let patterns=[
  [/^what (?:is|are) (.+?)[\s?]*$/i,'define',[1]],
  [/^who (?:is|are) (.+?)[\s?]*$/i,'define',[1]],
  [/^(?:tell me about|explain|describe) (.+?)[\s?]*$/i,'elaborate',[1]],
  [/^(.+?) (?:is a|are a|is an) (.+?)\.?$/i,'teach_isa',[1,2]],
  [/^(.+?) (?:is not|isn't|aren't) (.+?)\.?$/i,'teach_isnot',[1,2]],
  [/^(.+?) (?:is|are|means?|=) (.+?)\.?$/i,'teach',[1,2]],
  [/^(.+?) (?:has|have) (.+?)\.?$/i,'teach_has',[1,2]],
  [/^(.+?) (?:causes?|leads? to) (.+?)\.?$/i,'teach_causes',[1,2]],
  [/^(.+?) (?:prevents?|stops?) (.+?)\.?$/i,'teach_prevents',[1,2]],
  [/^(.+?) (?:increases?) (.+?)\.?$/i,'teach_increases',[1,2]],
  [/^(.+?) (?:decreases?|reduces?) (.+?)\.?$/i,'teach_decreases',[1,2]],
  [/^(.+?) (?:can|could) (.+?)\.?$/i,'teach_can',[1,2]],
  [/^(.+?) (?:is like|is similar to) (.+?)\.?$/i,'teach_similar',[1,2]],
  [/^(.+?) (?:is part of|belongs? to) (.+?)\.?$/i,'teach_partof',[1,2]],
  [/^(.+?) (?:contains?|is made of) (.+?)\.?$/i,'teach_contains',[1,2]],
  [/^why (?:does|do|is|are) (.+?)[\s?]*$/i,'why',[1]],
  [/^how (?:does|do|is|are|can) (.+?)[\s?]*$/i,'how',[1]],
  [/^compare (.+?) (?:and|vs|versus|,) (.+?)[\s?]*$/i,'compare',[1,2]],
  [/^what (?:if|would happen if) (.+?)[\s?]*$/i,'counterfactual',[1]],
  [/^(?:connect|relate|link) (.+?) (?:and|to|with) (.+?)[\s?]*$/i,'connect',[1,2]],
  [/^(?:think about|reflect on|analyze) (.+?)[\s?]*$/i,'reflect',[1]],
  [/^(?:what do you know|status|stats|brain dump)/i,'dump',[]],
  [/^(?:who|what) are you/i,'identity',[]],
  [/^(?:hello|hi|hey|yo)/i,'greet',[]],
  [/^(.+)\?$/,'question',[1]],
 ]
 for(let[regex,type,groups]of patterns){
  let m=lower.match(regex)
  if(m){let parts=groups.map(g=>m[g]?.trim()).filter(Boolean);let ex=parts.flatMap(p=>p.split(/\s+/).filter(w=>!STOP.has(w)&&w.length>2));return{type,parts,concepts:ex.length?ex:concepts,raw}}
 }
 return{type:'statement',parts:concepts,concepts,raw}
}

// â•â•â•â•â•â•â•â• MAIN REASONING â•â•â•â•â•â•â•â•
let kg=new KG(),logic=new Logic(kg),analogyEng=new Analogy(kg),mem=new Memory(),reasoningTrace=[]

async function reason(input){
 let intent=parse(input)
 let trace=[]
 let conf=0,response=''

 trace.push({label:'intent',content:`${intent.type} â€” concepts: ${intent.concepts.join(', ')}`})

 // Auto-enrich unknown concepts from web
 // First try the full phrase from parts, then individual concepts
 let fullPhrase=intent.parts[0]||intent.concepts.join(' ')
 let toEnrich=[]
 if(fullPhrase&&fullPhrase.length>2&&!['greet','identity','dump'].includes(intent.type)){
  let fpNode=kg.find(fullPhrase)
  if(!fpNode||kg.edgesOf(fpNode.id).length<3)toEnrich.push(fullPhrase)
 }
 let unknowns=intent.concepts.filter(c=>!kg.find(c)||kg.edgesOf(kg.find(c).id).length<3)
 toEnrich.push(...unknowns)
 toEnrich=[...new Set(toEnrich)]
 if(toEnrich.length>0&&!['greet','identity','dump'].includes(intent.type)){
  let fetched=await enrichAll(toEnrich,trace)
  if(fetched>0)trace.push({label:'enriched',content:`${fetched} facts acquired from web`,web:true})
 }

 // Also enrich known concepts that haven't been web-enriched yet
 let unenriched=intent.concepts.filter(c=>{let n=kg.find(c);return n&&!n.webEnriched&&kg.edgesOf(n.id).length<8})
 if(unenriched.length>0&&!['greet','identity','dump'].includes(intent.type)){
  await enrichAll(unenriched.slice(0,3),trace)
 }

 switch(intent.type){
  case 'greet':
   response=`i'm omniscience x. ${kg.size} concepts, ${kg.edgeCount} edges. i learn from you AND from the web. ask me about anything â€” i'll pull knowledge from ConceptNet and Wikipedia in real time, reason over it, and show you every step.`
   conf=1;break
  case 'identity':
   response=`i am a collective intelligence engine with live web learning. ${kg.size} concepts, ${kg.edgeCount} connections, ${webLearnedCount} learned from the web, ${inferenceCount} inferred by logic. ask me about any concept â€” if i don't know it, i fetch knowledge from ConceptNet (34 million facts) and Wikipedia, add it to my graph, and reason over it. everything transparent. everything traceable. no api key. no cost.`
   conf=1;break
  case 'dump':{
   let top=[...kg.nodes.values()].sort((a,b)=>b.accessCount-a.accessCount).slice(0,10)
   response=`knowledge: ${kg.size} concepts, ${kg.edgeCount} edges. web-learned: ${webLearnedCount}. inferred: ${inferenceCount}. memories: ${mem.episodes.length}.\n\ntop concepts: ${top.map(n=>`${n.name}${n.webEnriched?' ğŸŒ':''}`).join(', ')}\n\ncontradictions: ${kg.contradictions.length}`
   conf=1;break
  }

  case 'teach':case 'teach_isa':case 'teach_has':case 'teach_causes':
  case 'teach_prevents':case 'teach_increases':case 'teach_decreases':
  case 'teach_can':case 'teach_similar':case 'teach_partof':
  case 'teach_contains':case 'teach_isnot':{
   let[s,o]=intent.parts.length>=2?intent.parts:[intent.concepts[0],intent.concepts.slice(1).join(' ')]
   if(!s||!o){response='i need subject and object. try "X is Y" or "X causes Y"';conf=0.5;break}
   let relMap={teach:'is',teach_isa:'is_a',teach_has:'has',teach_causes:'causes',teach_prevents:'prevents',teach_increases:'increases',teach_decreases:'decreases',teach_can:'can',teach_similar:'similar_to',teach_partof:'part_of',teach_contains:'contains',teach_isnot:'is_not'}
   let rel=relMap[intent.type]||'is'
   let edge=kg.link(s,o,rel,0.85,'user')
   trace.push({label:'learn',content:`${s} â€”[${rel}]â†’ ${o}`})
   let node=kg.find(s)
   let deductions=node?logic.deduct(node):[]
   let hyps=node?logic.abduct(node):[]
   response=`learned: ${s} ${rel.replace(/_/g,' ')} ${o}.`
   if(edge?.contested)response+=` âš  contradicts existing knowledge.`
   if(deductions.length>0)response+=` deduced: ${deductions.map(d=>`${d.subject} ${d.rel} ${d.object}`).join(', ')}.`
   if(hyps.length>0)response+=` hypothesis: ${hyps[0].hypothesis}.`
   let inv={is_a:'has_instance',has:'belongs_to',causes:'caused_by',part_of:'contains',increases:'increased_by',decreases:'decreased_by'}
   if(inv[rel])kg.link(o,s,inv[rel],0.7,'inferred')
   conf=edge?.contested?0.5:0.9;break
  }

  case 'define':case 'elaborate':{
   let topic=intent.parts[0]||intent.concepts.join(' ')
   let node=kg.find(topic)
   if(!node){
    let found=intent.concepts.map(c=>kg.find(c)).find(Boolean)
    if(found){node=found;topic=node.name}
    else{response=`couldn't find information about ${topic} even after searching the web. try a different term or teach me directly.`;conf=0;break}
   }
   node.accessCount++;node.lastAccess=Date.now()
   let edges=kg.edgesOf(node.id)
   trace.push({label:'retrieve',content:`${topic}: ${edges.length} connections`})
   kg.spread(node.id,3)
   let deductions=logic.deduct(node)
   let anal=analogyEng.find(node)
   let hyps=logic.abduct(node)

   // Check if we have a Wikipedia summary cached
   let wikiSummary=webCache.get('wp:'+topic)||webCache.get('wp:'+topic.replace(/\s+/g,'_'))
   
   let grouped={};edges.forEach(e=>{
    let key=e.dir==='out'?e.rel:`${e.rel}_of`
    if(!grouped[key])grouped[key]=[]
    if(e.node)grouped[key].push({name:e.node.name,conf:e.confidence,sources:e.sources,contested:e.contested,source:e.source})
   })

   if(Object.keys(grouped).length===0&&!wikiSummary){
    response=`searched ConceptNet and Wikipedia but found limited structured data for "${topic}". teach me directly or try a related term.`;conf=0.1;break
   }

   // Start with Wikipedia summary if we have one
   let responseParts=[]
   if(wikiSummary&&wikiSummary.summary){
    responseParts.push(`<div class="web">ğŸ“– ${wikiSummary.summary.slice(0,300)}${wikiSummary.summary.length>300?'...':''}</div>`)
   }

   let parts=Object.entries(grouped).map(([rel,targets])=>{
    let items=targets.slice(0,6).map(t=>{
     let confCls=t.conf>0.7?'high':t.conf>0.4?'med':'low'
     let srcTag=t.source==='web'?' ğŸŒ':t.source==='inferred'?' âš¡':''
     return`${t.name}<span class="conf ${confCls}">${Math.round(t.conf*100)}%${srcTag}${t.contested?' âš ':''}</span>`
    })
    return`<b>${rel.replace(/_/g,' ')}</b>: ${items.join(', ')}`
   })
   if(parts.length>0)responseParts.push(parts.join('. ')+'.')
   if(deductions.length>0)responseParts.push(`âš¡ deduced: ${deductions.slice(0,3).map(d=>`${d.subject} ${d.rel} ${d.object} (${Math.round(d.confidence*100)}%)`).join('. ')}.`)
   if(anal)responseParts.push(`analogy: ${anal.source} â†” ${anal.target} (${Math.round(anal.score*100)}% structural match).`)
   if(hyps.length>0)responseParts.push(`hypothesis: ${hyps[0].hypothesis}.`)
   
   response=responseParts.join('<br><br>')
   conf=Math.max(...edges.map(e=>e.confidence),wikiSummary?0.7:0);break
  }

  case 'why':case 'how':{
   let nodes=intent.concepts.map(c=>kg.find(c)).filter(Boolean)
   if(nodes.length===0){response=`i don't have enough knowledge even after web search. teach me the components.`;conf=0;break}
   trace.push({label:'search',content:`causal chains through: ${nodes.map(n=>n.name).join(', ')}`})
   let allPaths=[]
   for(let node of nodes)allPaths.push(...kg.multiHop(node.id,null,5))
   if(nodes.length>=2)allPaths.push(...kg.multiHop(nodes[0].id,nodes[nodes.length-1].id,6))
   allPaths.sort((a,b)=>b.confidence-a.confidence)
   if(allPaths.length>0){
    let best=allPaths[0]
    let chain=best.path.map(s=>{
     let cc=s.confidence>0.7?'high':s.confidence>0.4?'med':'low'
     let src=s.source==='web'?' ğŸŒ':s.source==='inferred'?' âš¡':''
     return`${s.from.name} â€”[${s.rel}]â†’ ${s.to.name}<span class="conf ${cc}">${Math.round(s.confidence*100)}%${src}</span>`
    })
    response=`reasoning chain: ${chain.join(' â†’ ')}<br><br>overall: <span class="conf ${best.confidence>0.5?'high':'med'}">${Math.round(best.confidence*100)}%</span>`
    if(allPaths.length>1)response+=`<br><br>alt path (${Math.round(allPaths[1].confidence*100)}%): ${allPaths[1].path.map(s=>`${s.from.name} â†’${s.rel}â†’ ${s.to.name}`).join(' â†’ ')}`
    conf=best.confidence
   }else{response=`found concepts but can't chain them yet. teach me causal links.`;conf=0.1}
   break
  }

  case 'counterfactual':{
   let node=intent.concepts.map(c=>kg.find(c)).find(Boolean)
   if(!node){response=`need to know that concept first.`;conf=0;break}
   let effects=kg.counterfactual(node.id)
   if(effects.length>0){
    response=`if ${node.name} were removed:<br><br>`+effects.map(e=>{
     let cc=e.confidence>0.5?'high':'med'
     return`${e.effect}<span class="conf ${cc}">${Math.round(e.confidence*100)}%</span>`
    }).join('<br>')
    conf=Math.max(...effects.map(e=>e.confidence))
   }else{response=`not enough causal chains from ${node.name} to predict.`;conf=0.1}
   break
  }

  case 'compare':{
   let[a,b]=intent.parts;let na=kg.find(a),nb=kg.find(b)
   if(!na||!nb){response=`need to know both. teach me about ${!na?a:b}.`;conf=0;break}
   let sim=kg.similarity(na,nb),paths=kg.multiHop(na.id,nb.id,5)
   let eA=kg.edgesOf(na.id),eB=kg.edgesOf(nb.id)
   response=`<b>${a} vs ${b}</b> â€” similarity: ${Math.round(sim*100)}%<br>`
   let rA=new Set(eA.map(e=>e.rel+'â†’'+(e.node?.name||''))),rB=new Set(eB.map(e=>e.rel+'â†’'+(e.node?.name||'')))
   let shared=[...rA].filter(r=>rB.has(r)),oA=[...rA].filter(r=>!rB.has(r)),oB=[...rB].filter(r=>!rA.has(r))
   if(shared.length)response+=`shared: ${shared.slice(0,4).join('; ')}<br>`
   if(oA.length)response+=`${a} unique: ${oA.slice(0,4).join('; ')}<br>`
   if(oB.length)response+=`${b} unique: ${oB.slice(0,4).join('; ')}<br>`
   if(paths.length)response+=`path: ${paths[0].path.map(s=>`${s.from.name}â†’${s.to.name}`).join('â†’')}`
   conf=0.7;break
  }

  case 'connect':{
   let nodes=intent.concepts.map(c=>kg.find(c)).filter(Boolean)
   if(nodes.length<2){response=`need two known concepts.`;conf=0;break}
   let paths=kg.multiHop(nodes[0].id,nodes[nodes.length-1].id,6)
   if(paths.length>0){
    response=`connection (${Math.round(paths[0].confidence*100)}%): ${paths[0].path.map(s=>`${s.from.name} â€”[${s.rel}]â†’ ${s.to.name}`).join(' â†’ ')}`
    conf=paths[0].confidence
   }else{response=`no path found. teach me a link between them.`;conf=0}
   break
  }

  case 'reflect':{
   let topic=intent.parts[0]||intent.concepts[0];let node=kg.find(topic)
   if(!node){response=`haven't encountered ${topic}.`;conf=0;break}
   node.accessCount++;let edges=kg.edgesOf(node.id),similar=kg.findSimilar(node.id,5)
   let anal=analogyEng.find(node),hyps=logic.abduct(node),cf=kg.counterfactual(node.id)
   response=`<b>${topic}</b>: ${edges.length} connections. nearest: ${similar.slice(0,3).map(s=>`${s.node.name} (${Math.round(s.sim*100)}%)`).join(', ')}.`
   if(anal)response+=`<br>analogy: ${topic} â†” ${anal.target}.`
   if(hyps.length)response+=`<br>hypothesis: ${hyps[0].hypothesis}.`
   if(cf.length)response+=`<br>counterfactual: if removed â†’ ${cf[0].effect}.`
   conf=0.6;break
  }

  case 'question':case 'statement':default:{
   let concepts=intent.concepts
   if(concepts.length<2){response=`tell me more. i learn from everything.`;conf=0.3;break}
   for(let i=0;i<concepts.length-1;i++)kg.link(concepts[i],concepts[i+1],'related',0.4,'context')
   let best=null,bestE=0
   concepts.forEach(c=>{let n=kg.find(c);if(n){let e=kg.edgesOf(n.id).length;if(e>bestE){bestE=e;best=n}}})
   if(best&&bestE>3){
    let edges=kg.edgesOf(best.id).slice(0,5)
    response=`absorbed. ${best.name} is densest â€” connects to ${edges.map(e=>e.node?.name).filter(Boolean).join(', ')}.`
    let anal=analogyEng.find(best);if(anal)response+=` analogy: ${best.name} â†” ${anal.target}.`
   }else response=`registered ${concepts.length} concepts. keep teaching.`
   conf=0.4
  }
 }

 trace.push({label:'confidence',content:`${Math.round(conf*100)}%`})
 mem.store(input,response,intent.concepts,trace,conf)
 kg.decay();reasoningTrace=trace
 return{text:response,chain:trace,confidence:conf}
}

// â•â•â•â•â•â•â•â• GRAPH VIZ â•â•â•â•â•â•â•â•
const gc=document.getElementById('graphCanvas'),gctx=gc.getContext('2d')
let gW,gH,gCam={x:0,y:0,z:0.7},gDrag=false,gStart={x:0,y:0},nodePos=new Map()

function stepLayout(){
 let pos=[...nodePos.entries()]
 for(let i=0;i<pos.length;i++){
  for(let j=i+1;j<pos.length;j++){
   let a=pos[i][1],b=pos[j][1],dx=b.x-a.x,dy=b.y-a.y,d=Math.sqrt(dx*dx+dy*dy)+1,f=150/d
   a.vx-=dx/d*f;a.vy-=dy/d*f;b.vx+=dx/d*f;b.vy+=dy/d*f
  }
 }
 for(let e of kg.edges){
  let a=nodePos.get(e.from),b=nodePos.get(e.to);if(!a||!b)continue
  let dx=b.x-a.x,dy=b.y-a.y,d=Math.sqrt(dx*dx+dy*dy)+1,f=(d-70)*0.008*e.strength
  a.vx+=dx/d*f;a.vy+=dy/d*f;b.vx-=dx/d*f;b.vy-=dy/d*f
 }
 for(let[_,p]of nodePos){p.x+=p.vx*0.3;p.y+=p.vy*0.3;p.vx*=0.85;p.vy*=0.85}
}

function renderGraph(){
 if(!gc.offsetWidth)return;gW=gc.width=gc.offsetWidth;gH=gc.height=gc.offsetHeight
 gctx.fillStyle='#070910';gctx.fillRect(0,0,gW,gH)
 gctx.save();gctx.translate(gW/2+gCam.x,gH/2+gCam.y);gctx.scale(gCam.z,gCam.z)
 for(let e of kg.edges){
  let a=nodePos.get(e.from),b=nodePos.get(e.to);if(!a||!b)continue
  let alpha=0.03+e.strength*0.025
  gctx.strokeStyle=e.source==='web'?`rgba(167,139,250,${alpha})`:e.contested?`rgba(255,200,80,${alpha})`:`rgba(107,150,255,${alpha})`
  gctx.lineWidth=0.5+e.strength*0.2;gctx.beginPath();gctx.moveTo(a.x,a.y);gctx.lineTo(b.x,b.y);gctx.stroke()
 }
 for(let[id,pos]of nodePos){
  let node=kg.nodes.get(id);if(!node)continue
  let size=2.5+Math.min(kg.edgesOf(id).length*0.4,7)+node.activation*3
  let alpha=0.15+node.activation*0.4+Math.min(node.accessCount*0.02,0.3)
  gctx.fillStyle=node.webEnriched?`rgba(167,139,250,${alpha})`:node.contested?`rgba(255,200,80,${alpha})`:`rgba(107,150,255,${alpha})`
  gctx.beginPath();gctx.arc(pos.x,pos.y,size,0,Math.PI*2);gctx.fill()
  if(size>3.5||node.activation>0.3){
   gctx.fillStyle=`rgba(200,215,240,${alpha*0.5})`;gctx.font=`${Math.max(7,size)}px system-ui`
   gctx.fillText(node.name,pos.x+size+2,pos.y+2)
  }
 }
 gctx.restore()
}
gc.addEventListener('mousedown',e=>{gDrag=true;gStart={x:e.clientX-gCam.x,y:e.clientY-gCam.y}})
gc.addEventListener('mousemove',e=>{if(gDrag){gCam.x=e.clientX-gStart.x;gCam.y=e.clientY-gStart.y}})
gc.addEventListener('mouseup',()=>gDrag=false)
gc.addEventListener('wheel',e=>{e.preventDefault();gCam.z*=e.deltaY>0?0.9:1.1;gCam.z=Math.max(0.05,Math.min(5,gCam.z))})

// â•â•â•â•â•â•â•â• UI â•â•â•â•â•â•â•â•
let chatEl=document.getElementById('chat')
function addMsg(cls,html,chain=''){
 let d=document.createElement('div');d.className='msg '+cls
 d.innerHTML=(chain?`<div class="chain">${chain}</div>`:'')+html
 chatEl.appendChild(d);if(chatEl.children.length>150)chatEl.removeChild(chatEl.firstChild)
 chatEl.scrollTop=chatEl.scrollHeight
}

function switchView(name){
 document.querySelectorAll('.view').forEach(v=>v.classList.remove('active'))
 document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'))
 document.getElementById('v-'+name).classList.add('active')
 event.target.classList.add('active')
}

function updateUI(conf){
 document.getElementById('mC').textContent=kg.size
 document.getElementById('mE').textContent=kg.edgeCount
 document.getElementById('mW').textContent=webLearnedCount
 document.getElementById('mI').textContent=inferenceCount
 document.getElementById('mConf').textContent=conf!=null?Math.round(conf*100)+'%':'â€”'
 // Reasoning view
 document.getElementById('reasoningView').innerHTML=reasoningTrace.map(s=>`<div class="r-step${s.web?' web':''}"><div class="label">${s.label}</div><div class="content">${s.content}</div></div>`).join('')
 // Right panel
 let top=[...kg.nodes.values()].sort((a,b)=>b.accessCount-a.accessCount).slice(0,12)
 document.getElementById('rightPanel').innerHTML=`
  <h4>knowledge</h4>
  <div class="row"><span>concepts</span><b style="color:var(--blue)">${kg.size}</b></div>
  <div class="row"><span>connections</span><b style="color:var(--blue)">${kg.edgeCount}</b></div>
  <div class="row"><span>web-learned</span><b style="color:var(--purple)">${webLearnedCount}</b></div>
  <div class="row"><span>inferred</span><b style="color:var(--green)">${inferenceCount}</b></div>
  <div class="row"><span>contradictions</span><b style="color:var(--gold)">${kg.contradictions.length}</b></div>
  <div class="row"><span>memories</span><b style="color:var(--blue)">${mem.episodes.length}</b></div>
  <div class="row"><span>analogies</span><b style="color:var(--blue)">${analogyEng.found.length}</b></div>
  <h4>top concepts</h4>
  ${top.map(n=>`<span class="tag ${n.webEnriched?'web':'user'}">${n.name}${n.webEnriched?' ğŸŒ':''}</span>`).join(' ')}
  <h4>recent contradictions</h4>
  ${kg.contradictions.slice(-3).map(c=>`<div class="edge-item" style="color:var(--gold)">${c.a} ${c.rel1}/${c.rel2} ${c.b}</div>`).join('')||'<div class="edge-item">none</div>'}
  <h4>recent inferences</h4>
  ${logic.inferences.slice(-5).map(i=>`<div class="edge-item">${i.subject} ${i.rel} ${i.object} (${Math.round(i.confidence*100)}%)</div>`).join('')||'<div class="edge-item">none</div>'}
  <h4>hypotheses</h4>
  ${logic.hypotheses.slice(-3).map(h=>`<div class="edge-item">${h.hypothesis}</div>`).join('')||'<div class="edge-item">none</div>'}
  <h4>memory patterns</h4>
  ${mem.patterns.slice(-3).map(p=>`<div class="edge-item">${p.concepts.join(', ')}</div>`).join('')||'<div class="edge-item">consolidating...</div>'}
 `
 // Sync graph positions
 for(let[id]of kg.nodes){if(!nodePos.has(id))nodePos.set(id,{x:(Math.random()-0.5)*400,y:(Math.random()-0.5)*400,vx:0,vy:0})}
}

async function go(){
 let inp=document.getElementById('in'),text=inp.value.trim();if(!text)return
 inp.value='';addMsg('u',text)
 // Show thinking indicator
 let thinkingDiv=document.createElement('div');thinkingDiv.className='msg ai'
 thinkingDiv.innerHTML='<span class="fetching"><span class="loading"></span> thinking & searching the web...</span>'
 chatEl.appendChild(thinkingDiv);chatEl.scrollTop=chatEl.scrollHeight
 let r=await reason(text)
 chatEl.removeChild(thinkingDiv)
 let chainStr=r.chain.map(s=>`${s.label}: ${s.content}`).join(' â†’ ')
 addMsg('ai',r.text,chainStr)
 updateUI(r.confidence)
 save()
}

// â•â•â•â•â•â•â•â• SEED â•â•â•â•â•â•â•â•
function seed(){
 let facts=[
  ['animal','living thing','is_a'],['plant','living thing','is_a'],['human','animal','is_a'],
  ['dog','mammal','is_a'],['cat','mammal','is_a'],['mammal','animal','is_a'],
  ['bird','fly','can'],['fish','swim','can'],['human','think','can'],
  ['sun','star','is_a'],['earth','planet','is_a'],['earth','sun','orbits'],
  ['water','hydrogen','contains'],['water','oxygen','contains'],
  ['learning','change','causes'],['exercise','health','increases'],
  ['pollution','health','decreases'],['gravity','falling','causes'],
  ['sun','light','causes'],['light','photosynthesis','causes'],
  ['photosynthesis','oxygen','causes'],['oxygen','breathing','enables'],
  ['love','emotion','is_a'],['fear','emotion','is_a'],
 ]
 facts.forEach(([a,b,r])=>kg.link(a,b,r,0.9,'seed'))
}

// â•â•â•â•â•â•â•â• PERSISTENCE â•â•â•â•â•â•â•â•
async function save(){
 try{
  let data={
   nodes:[...kg.nodes.values()].map(n=>({id:n.id,name:n.name,type:n.type,embedding:[...n.embedding],sources:n.sources,accessCount:n.accessCount,contested:n.contested,webEnriched:n.webEnriched})),
   edges:kg.edges.map(e=>({from:e.from,to:e.to,rel:e.rel,confidence:e.confidence,sources:e.sources,strength:e.strength,contested:e.contested,source:e.source})),
   contradictions:kg.contradictions.slice(-50),
   inferences:logic.inferences.slice(-80),hypotheses:logic.hypotheses.slice(-40),
   analogies:analogyEng.found.slice(-20),episodes:mem.episodes.slice(-80),
   patterns:mem.patterns.slice(-15),nid,webLearnedCount,inferenceCount
  }
  await window.storage.set('omniscience-x',JSON.stringify(data))
 }catch(e){}
}

async function load(){
 try{
  let r=await window.storage.get('omniscience-x')
  if(r&&r.value){
   let data=JSON.parse(r.value);nid=data.nid||0;webLearnedCount=data.webLearnedCount||0;inferenceCount=data.inferenceCount||0
   data.nodes.forEach(n=>{let node=new Node(n.name,n.type);node.id=n.id;node.embedding=new Float32Array(n.embedding);node.sources=n.sources;node.accessCount=n.accessCount;node.contested=n.contested;node.webEnriched=n.webEnriched;kg.nodes.set(node.id,node);kg.edgeIdx.set(node.id,[])})
   data.edges.forEach(e=>{let edge=new Edge(e.from,e.to,e.rel,e.confidence);edge.sources=e.sources;edge.strength=e.strength;edge.contested=e.contested;edge.source=e.source;kg.edges.push(edge);kg.edgeIdx.get(e.from)?.push({edge,dir:'out'});kg.edgeIdx.get(e.to)?.push({edge,dir:'in'})})
   kg.contradictions=data.contradictions||[];logic.inferences=data.inferences||[];logic.hypotheses=data.hypotheses||[]
   analogyEng.found=data.analogies||[];mem.episodes=data.episodes||[];mem.patterns=data.patterns||[]
   addMsg('sys',`restored. ${kg.size} concepts. ${kg.edgeCount} edges. ${webLearnedCount} web-learned.`)
   return true
  }
 }catch(e){}
 return false
}

// â•â•â•â•â•â•â•â• BOOT â•â•â•â•â•â•â•â•
async function boot(){
 let loaded=await load()
 if(!loaded){
  seed()
  addMsg('sys',`omniscience x initialized. ${kg.size} seed concepts.`)
  addMsg('ai',`i am omniscience x.<br><br>everything from omniscience â€” knowledge graphs, multi-hop reasoning, contradiction detection, confidence propagation, counterfactual analysis, analogies, deduction â€” <b>plus live web learning</b>.<br><br>ask me about <i>anything</i>. if i don't know it, i search <b>ConceptNet</b> (34 million common-sense facts) and <b>Wikipedia</b> in real time. i add what i find to my graph, reason over it, and show you every step.<br><br>ğŸŒ = learned from web &nbsp; âš¡ = inferred by logic &nbsp; âš  = contested<br><br>try: "what is photosynthesis" or "compare dogs and cats" or "why do humans dream"<br><br>no api key. no cost. no rules. no ceiling. and now â€” no limits on knowledge.`,`boot â†’ cognitive architecture + web learning online`)
 }
 updateUI(null)
 setInterval(()=>{stepLayout();if(document.getElementById('v-graph').classList.contains('active'))renderGraph()},50)
}
boot()
</script>
</body>
</html>
